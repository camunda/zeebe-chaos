"use strict";(self.webpackChunkzell_chaos=self.webpackChunkzell_chaos||[]).push([[1610],{29218:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var a=n(39355),i=n(74848),r=n(28453);const o={layout:"posts",title:"Camunda Exporter MVP",date:new Date("2024-10-24T00:00:00.000Z"),categories:["camunda","exporter"],tags:["performance"],authors:"zell"},s="Chaos Day Summary",l={authorsImageUrls:[void 0]},c=[{value:"Camunda Exporter",id:"camunda-exporter",level:2},{value:"MVP",id:"mvp",level:3}];function d(e){const t={a:"a",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"After a long pause, I come back with an interesting topic to share and experiment with. Right now we are re-architecture\nCamunda 8. One important part (which I'm contributing to) is to get rid of Webapps Importer/Archivers and move\ndata aggregation closer to the engine (inside a Zeebe Exporter)."}),"\n",(0,i.jsx)(t.p,{children:"Today, I want to experiment with the first increment/iteration of our so-called MVP. The MVP targets green field installations where you simply deploy Camunda (with a new Camunda Exporter enabled) without Importers."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"TL;DR;"})," All our experiments were successful. The MVP is a success, and we are looking forward to further improvements and additions. Next stop Iteration 2: Adding Archiving historic data and preparing for data migration (and polishing MVP)."]}),"\n",(0,i.jsx)(t.h2,{id:"camunda-exporter",children:"Camunda Exporter"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"https://github.com/camunda/product-hub/issues/2128",children:"Camunda Exporter project"})," deserves a complete own blog post, here is just a short summary."]}),"\n",(0,i.jsx)(t.p,{children:"Our current Camunda architecture looks something like this (simplified)."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"current",src:n(11535).A+"",width:"1096",height:"885"})}),"\n",(0,i.jsx)(t.p,{children:"It has certain challenges, like:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Space: duplication of data in ES"}),"\n",(0,i.jsx)(t.li,{children:"Maintenance: duplication of importer and archiver logic"}),"\n",(0,i.jsx)(t.li,{children:"Performance: Round trip (delay) of data visible to the user"}),"\n",(0,i.jsx)(t.li,{children:"Complexity: installation and operational complexity (we need separate pods to deploy)"}),"\n",(0,i.jsx)(t.li,{children:"Scalability: The Importer is not scalable in the same way as Zeebe or brokers (and workload) are."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"These challenges we obviously wanted to overcome and the plan (as mentioned earlier) is to get rid of the need of separate importers and archivers (and in general to have separate application; but this is a different topic)."}),"\n",(0,i.jsx)(t.p,{children:"The plan for this project looks something like this:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"plan",src:n(45852).A+"",width:"1228",height:"904"})}),"\n",(0,i.jsx)(t.p,{children:"We plan to:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Harmonize the existing indices stored in Elasticsearch/Opensearch","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Space: Reduce the unnecessary data duplication"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Move importer and archiver logic into a new Camunda exporter","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Performance: This should allow us to reduce one additional hop (as we don't need to use ES/OS as a queue)"}),"\n",(0,i.jsx)(t.li,{children:"Maintenance: Indices and business logic is maintained in one place"}),"\n",(0,i.jsx)(t.li,{children:"Scalability: With this approach, we can scale with partitions, as Camunda Exporters are executed for each partition separately (soon partition scaling will be introduced)"}),"\n",(0,i.jsx)(t.li,{children:"Complexity: The Camunda Exporter will be built-in and shipped with Zeebe/Camunda 8. No additional pod/application is needed."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Note: Optimize is right now out of scope (due to time), but will later be part of this as well."}),"\n",(0,i.jsx)(t.h3,{id:"mvp",children:"MVP"}),"\n",(0,i.jsx)(t.p,{children:"After we know what we want to achieve what is the Minimum viable product (MVP)?"}),"\n",(0,i.jsxs)(t.p,{children:["We have divided the Camunda Exporter in 3-4 iterations. You can see and read more about this ",(0,i.jsx)(t.a,{href:"https://github.com/camunda/issues/issues/803",children:"here"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The first iteration contains the MVP (the first breakthrough). Providing the Camunda Exporter with the basic functionality ported from the Operate and Tasklist importers, writing into harmonized indices."}),"\n",(0,i.jsx)(t.p,{children:"The MVP is targeting green field installations (clean installations) of Camunda 8 with Camunda Exporter without running the old Importer (no data migration yet),"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"mvp",src:n(71082).A+"",width:"1069",height:"870"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11535:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/current-miro-659b193b670b1b604ebb32ff30b067a4.png"},45852:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/how-brown-field-929f9a23e6dfee9ede15e76b1a134fdc.png"},71082:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/it1-mvp-421ca897b91c0d03c1d77adde73b48a7.png"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var a=n(96540);const i={},r=a.createContext(i);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:t},e.children)}},39355:e=>{e.exports=JSON.parse('{"permalink":"/zeebe-chaos/2024/10/24/Camunda-Exporter-MVP","editUrl":"https://github.com/zeebe-io/zeebe-chaos/blob/master/chaos-days/blog/2024-10-24-Camunda-Exporter-MVP/index.md","source":"@site/blog/2024-10-24-Camunda-Exporter-MVP/index.md","title":"Camunda Exporter MVP","description":"After a long pause, I come back with an interesting topic to share and experiment with. Right now we are re-architecture","date":"2024-10-24T00:00:00.000Z","tags":[{"inline":true,"label":"performance","permalink":"/zeebe-chaos/tags/performance"}],"readingTime":6.15,"hasTruncateMarker":true,"authors":[{"name":"Christopher Kujawa","title":"Chaos Engineer @ Zeebe","url":"https://github.com/ChrisKujawa","page":{"permalink":"/zeebe-chaos/authors/zell"},"imageURL":"https://github.com/ChrisKujawa.png","key":"zell"}],"frontMatter":{"layout":"posts","title":"Camunda Exporter MVP","date":"2024-10-24T00:00:00.000Z","categories":["camunda","exporter"],"tags":["performance"],"authors":"zell"},"unlisted":false,"prevItem":{"title":"Impact of Camunda Exporter on processing performance","permalink":"/zeebe-chaos/2024/11/14/Impact-of-Camunda-Exporter-on-processing-performance"},"nextItem":{"title":"Optimizing cluster sizing using a real world benchmark","permalink":"/zeebe-chaos/2024/10/14/Optimizing-cluster-sizing-using-a-real-world-benchmark"}}')}}]);