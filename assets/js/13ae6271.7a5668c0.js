"use strict";(self.webpackChunkzell_chaos=self.webpackChunkzell_chaos||[]).push([[2073],{54507:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=n(74848),a=n(28453);const i={layout:"posts",title:"Old-Clients",date:new Date("2021-09-23T00:00:00.000Z"),categories:["chaos_experiment","clients"],tags:["availability"],authors:"zell"},r="Chaos Day Summary",o={permalink:"/zeebe-chaos/2021/09/23/Old-Clients",editUrl:"https://github.com/zeebe-io/zeebe-chaos/blob/master/chaos-days/blog/2021-09-23-Old-Clients/index.md",source:"@site/blog/2021-09-23-Old-Clients/index.md",title:"Old-Clients",description:"It has been awhile since the last post, I'm happy to be back.",date:"2021-09-23T00:00:00.000Z",tags:[{inline:!0,label:"availability",permalink:"/zeebe-chaos/tags/availability"}],readingTime:2.61,hasTruncateMarker:!0,authors:[{name:"Christopher Kujawa",title:"Chaos Engineer @ Zeebe",url:"https://github.com/zelldon",page:{permalink:"/zeebe-chaos/authors/zell"},imageURL:"https://github.com/zelldon.png",key:"zell"}],frontMatter:{layout:"posts",title:"Old-Clients",date:"2021-09-23T00:00:00.000Z",categories:["chaos_experiment","clients"],tags:["availability"],authors:"zell"},unlisted:!1,prevItem:{title:"Recovery (Fail Over) time",permalink:"/zeebe-chaos/2021/10/05/recovery-time"},nextItem:{title:"Slow Network",permalink:"/zeebe-chaos/2021/07/06/Slow-Network"}},l={authorsImageUrls:[void 0]},c=[{value:"Chaos Experiment",id:"chaos-experiment",level:2},{value:"Expected",id:"expected",level:3},{value:"Actual",id:"actual",level:3},{value:"Result",id:"result",level:3},{value:"Found Bugs",id:"found-bugs",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"It has been awhile since the last post, I'm happy to be back."}),"\n",(0,s.jsxs)(t.p,{children:["In today's chaos day we want to verify the hypothesis from ",(0,s.jsx)(t.a,{href:"https://github.com/zeebe-io/zeebe-chaos/issues/34",children:"zeebe-chaos#34"})," that old\nclients can't disrupt a running cluster."]}),"\n",(0,s.jsx)(t.p,{children:"It might happen that after upgrading your Zeebe to the newest shiny version, you might forget to\nupdate some of your workers or starters etc. This should normally not an issue since Zeebe is\nbackwards compatible, client wise since 1.x. But what happens when older clients are used. Old\nclients should not have a negative effect on a running cluster."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"TLDR"})," Older clients (0.26) have no negative impact on a running cluster (1.2), and clients after\n1.x are still working with the latest version."]}),"\n",(0,s.jsx)(t.h2,{id:"chaos-experiment",children:"Chaos Experiment"}),"\n",(0,s.jsx)(t.p,{children:"We will run a simple setup with, three nodes and three partitions (replication factor 3). The\nversion we use is the latest release candidate (1.2.0). Normally we run a load of 200 process\ninstances per second (pi/s) on our benchmarks. This time we will put a load of 100 pi/s to get\nsomething running and start an old starter (v0.26.x) with the same frequency. Later we will scale\nthe old starter to see whether it makes any effect."}),"\n",(0,s.jsx)(t.h3,{id:"expected",children:"Expected"}),"\n",(0,s.jsx)(t.p,{children:"We expect that we can start and complete the 100 pi/s, since we can normally run 200 pi/s."}),"\n",(0,s.jsx)(t.h3,{id:"actual",children:"Actual"}),"\n",(0,s.jsx)(t.p,{children:"The cluster was first started with starters of the same version, and we saw a stable load of ~100\nprocess instances completed per second. After starting the old starters (with version 0.26.3), we\ncan't observe any difference."}),"\n",(0,s.jsxs)(t.p,{children:["Interesting is even when scaling the starters up to 10 replicas, which means 1000 PI creations per\nsecond, it doesn't seem to make any effect. ",(0,s.jsx)(t.em,{children:"Side note:"})," The\n",(0,s.jsx)(t.a,{href:"https://github.com/camunda-cloud/zeebe/tree/develop/benchmarks/project",children:"starters"})," have been\nmodified, such they only start instances without deploying the model."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"old26-general",src:n(73697).A+"",width:"2481",height:"992"})}),"\n",(0,s.jsx)(t.p,{children:"The drops we see in the processing are related to restart's."}),"\n",(0,s.jsx)(t.p,{children:"The gateway and grpc metrics doesn't indicate that more requests are sent."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"old26-grpc",src:n(74745).A+"",width:"2480",height:"641"}),"\n",(0,s.jsx)(t.img,{alt:"old26-gateway",src:n(99515).A+"",width:"2469",height:"650"})]}),"\n",(0,s.jsx)(t.p,{children:"If we take a look in the clients log, we can see that the request are failing because the RPC Method names have been changed between 0.26 and 1.0."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"java.util.concurrent.ExecutionException: io.grpc.StatusRuntimeException: UNIMPLEMENTED: Method not found: gateway_protocol.Gateway/CreateWorkflowInstance\n\t...\nCaused by: io.grpc.StatusRuntimeException: UNIMPLEMENTED: Method not found: gateway_protocol.Gateway/CreateWorkflowInstance\n\t...\n"})}),"\n",(0,s.jsx)(t.p,{children:'It seems this kind of "old" requests can be blocked quite early in the request chain to make no effect.'}),"\n",(0,s.jsx)(t.p,{children:"In order to experiment a bit further I created a starter image with version 1.0 to see whether this still works with our newest release candidate 1.2."}),"\n",(0,s.jsx)(t.p,{children:"We can see in the metrics right after starting the starter that the throughput goes up and we can reach our 200 pi/s."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"old10-general",src:n(68810).A+"",width:"2484",height:"1000"})}),"\n",(0,s.jsx)(t.p,{children:"We run the benchmark overnight, and we haven't seen any issues. Be aware that the throughput is calculated over the 24h which makes is lower than 200."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"general",src:n(6009).A+"",width:"2481",height:"994"})}),"\n",(0,s.jsx)(t.p,{children:"Furthermore, taking a look at the resource consumption, especially at the gateway, gives no evidence that something wrong is going on."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"res",src:n(69307).A+"",width:"2473",height:"647"})}),"\n",(0,s.jsx)(t.h3,{id:"result",children:"Result"}),"\n",(0,s.jsxs)(t.p,{children:["We were able to confirm the hypothesis written in ",(0,s.jsx)(t.a,{href:"https://github.com/zeebe-io/zeebe-chaos/issues/34",children:"zeebe-chaos#34"}),", that an old client can't disrupt a running cluster."]}),"\n",(0,s.jsx)(t.h2,{id:"found-bugs",children:"Found Bugs"}),"\n",(0,s.jsx)(t.p,{children:"None this time :)"})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},6009:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/general-67c5d494df6c66211457861139475c6c.png"},68810:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/old10-general-90bb179937d9178c12b16f0cdea22281.png"},99515:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/old26-gateway-dd4afa5333796343795b4d80ad498e6b.png"},73697:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/old26-general-1cbfdf95d7c9b19cad8ca10aa921f34b.png"},74745:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/old26-grpc-b5da2bbcf038492c59dea93f36619e69.png"},69307:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/res-951c069149e3ae14d08a997e6fe974b2.png"},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(96540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);