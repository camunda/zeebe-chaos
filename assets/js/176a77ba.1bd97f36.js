"use strict";(globalThis.webpackChunkzell_chaos=globalThis.webpackChunkzell_chaos||[]).push([[4265],{40187(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var r=n(9915),a=n(74848),o=n(28453);const i={layout:"posts",title:"Optimizing cluster sizing using a real world benchmark",date:new Date("2024-10-14T00:00:00.000Z"),categories:["chaos_experiment","performance"],tags:["performance"],authors:"rodrigo"},s="Chaos Day Summary",c={authorsImageUrls:[void 0]},l=[];function p(e){const t={p:"p",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Our first goal of this experiment is to use a benchmarks to\nderive new optimized cluster configuration that can handle\nat least 100 tasks per second, while maintaining low backpressure and low latency."}),"\n",(0,a.jsx)(t.p,{children:"For our experiment, we use a newly defined realistic benchmark (with a more complex process model). More about this in a separate blog post."}),"\n",(0,a.jsx)(t.p,{children:"The second goal is to scale out optimized cluster configuration\nresources linearly and see if the performance scales accordingly."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"TL;DR;"})}),"\n",(0,a.jsx)(t.p,{children:"We used a realistic benchmark to derive a new\ncluster configuration based on previous requirements."}),"\n",(0,a.jsx)(t.p,{children:"When we scale this base configuration linearly we see that the performance\nincreases almost linearly as well, while maintaining low\nbackpressure and low latency."})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},28453(e,t,n){n.d(t,{R:()=>i,x:()=>s});var r=n(96540);const a={},o=r.createContext(a);function i(e){const t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(o.Provider,{value:t},e.children)}},9915(e){e.exports=JSON.parse('{"permalink":"/zeebe-chaos/2024/10/14/Optimizing-cluster-sizing-using-a-real-world-benchmark","editUrl":"https://github.com/camunda/zeebe-chaos/blob/master/chaos-days/blog/2024-10-14-Optimizing-cluster-sizing-using-a-real-world-benchmark/index.md","source":"@site/blog/2024-10-14-Optimizing-cluster-sizing-using-a-real-world-benchmark/index.md","title":"Optimizing cluster sizing using a real world benchmark","description":"Our first goal of this experiment is to use a benchmarks to","date":"2024-10-14T00:00:00.000Z","tags":[{"inline":true,"label":"performance","permalink":"/zeebe-chaos/tags/performance"}],"readingTime":5.33,"hasTruncateMarker":true,"authors":[{"name":"Rodrigo Lopes","title":"Associate Software Engineer @ Zeebe","url":"https://github.com/rodrigo-lourenco-lopes","imageURL":"https://github.com/rodrigo-lourenco-lopes.png","key":"rodrigo","page":null}],"frontMatter":{"layout":"posts","title":"Optimizing cluster sizing using a real world benchmark","date":"2024-10-14T00:00:00.000Z","categories":["chaos_experiment","performance"],"tags":["performance"],"authors":"rodrigo"},"unlisted":false,"prevItem":{"title":"Camunda Exporter MVP","permalink":"/zeebe-chaos/2024/10/24/Camunda-Exporter-MVP"},"nextItem":{"title":"Improve Operate import latency","permalink":"/zeebe-chaos/2024/08/19/Operate-improve-import-latency"}}')}}]);