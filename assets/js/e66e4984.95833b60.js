"use strict";(self.webpackChunkzell_chaos=self.webpackChunkzell_chaos||[]).push([[4072],{5505:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=n(20349),i=n(74848),r=n(28453);const o={layout:"posts",title:"Fault-tolerant processing of process instances",date:new Date("2021-03-09T00:00:00.000Z"),categories:["chaos_experiment","broker","processing"],tags:["availability","data"],authors:"zell"},a="Chaos Day Summary",l={authorsImageUrls:[void 0]},c=[{value:"Chaos Experiment",id:"chaos-experiment",level:2},{value:"Expected",id:"expected",level:3},{value:"Experiment Definition",id:"experiment-definition",level:3},{value:"Timer start events",id:"timer-start-events",level:4},{value:"Continue process instance",id:"continue-process-instance",level:4},{value:"Outcome",id:"outcome",level:3},{value:"Testbench",id:"testbench",level:4},{value:"Found Bugs",id:"found-bugs",level:4},{value:"Chaos Experiments not working correctly",id:"chaos-experiments-not-working-correctly",level:5},{value:"Redeployment causes retrigger timer",id:"redeployment-causes-retrigger-timer",level:5}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Today I wanted to add another chaos experiment, to increase our automated chaos experiments collection. This time we will deploy a process model (with timer start event), restart a node and complete the process instance via ",(0,i.jsx)(t.code,{children:"zbctl"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"TL;DR;"})}),"\n",(0,i.jsx)(t.p,{children:"I was able to create the chaos toolkit experiment. It shows us that we are able to restore our state after fail over, which means we can trigger timer start events to create process instances even if they have been deployed before fail-over. Plus we are able to complete these instances."}),"\n",(0,i.jsx)(t.h2,{id:"chaos-experiment",children:"Chaos Experiment"}),"\n",(0,i.jsx)(t.p,{children:"For testing, I have run our normal setup of three nodes, three partitions and replication factor three in our zeebe gke cluster.\nLater I want to automate the experiment against the production cluster plans."}),"\n",(0,i.jsx)(t.h3,{id:"expected",children:"Expected"}),"\n",(0,i.jsx)(t.p,{children:"We want to verify whether the processing of process instances continues even if we restart a leader in between. For that we do the following experiment:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Verify Steady State: All Pods are ready"}),"\n",(0,i.jsxs)(t.li,{children:["Introduce Chaos:","\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"Action:"})," Deploy process with timer start event (",(0,i.jsx)(t.code,{children:"PT1M"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"Action:"})," Restart leader of partition one"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"Probe:"})," We can activate and complete an job of a specific type"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.li,{children:"Verify Steady State: All Pods are ready"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note:"})," ",(0,i.jsx)(t.em,{children:"We know that timer start events currently only scheduled on partition one, which means it is enough to just restart the leader of partition one for our experiment."})," We use this property to reduce the blast radius. Later we could introduce an intermediate timer catch event and start many workflow instances on multiple partitions to verify whether this works on all partitions."]}),"\n",(0,i.jsx)(t.p,{children:"Model will look like this:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"model",src:n(93218).A+"",width:"903",height:"276"}),")"]}),"\n",(0,i.jsx)(t.h3,{id:"experiment-definition",children:"Experiment Definition"}),"\n",(0,i.jsx)(t.p,{children:"The experiment definition looks like the following:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-json",children:'{\n    "version": "0.1.0",\n    "title": "Zeebe process instance continuation",\n    "description": "Zeebe processing of process instances should be fault-tolerant. Zeebe should be able to handle fail-overs and continue process instances after a new leader starts with processing.",\n    "contributions": {\n        "reliability": "high",\n        "availability": "high"\n    },\n    "steady-state-hypothesis": {\n        "title": "Zeebe is alive",\n        "probes": [\n            {\n                "name": "All pods should be ready",\n                "type": "probe",\n                "tolerance": 0,\n                "provider": {\n                    "type": "process",\n                    "path": "verify-readiness.sh",\n                    "timeout": 900\n                }\n            }\n        ]\n    },\n    "method": [\n        {\n            "type": "action",\n            "name": "Deploy process model",\n            "provider": {\n                "type": "process",\n                "path": "deploy-specific-model.sh", \n                "arguments": [ "chaosTimerStart.bpmn" ]\n            }\n        },\n         {\n              "type": "action",\n              "name": "Restart partition leader",\n              "provider": {\n                   "type": "process",\n                   "path": "shutdown-gracefully-partition.sh",\n                   "arguments": [ "Leader", "1" ]\n              }\n         },\n        {\n            "type": "probe",\n            "name": "Complete process instance",\n            "tolerance": 0,\n            "provider": {\n                "type": "process",\n                "path": "complete-instance.sh",\n                "arguments": ["chaos"],\n                "timeout": 900\n            }\n        }\n    ],\n    "rollbacks": []\n}\n'})}),"\n",(0,i.jsx)(t.h4,{id:"timer-start-events",children:"Timer start events"}),"\n",(0,i.jsxs)(t.p,{children:["In order to trigger the timer start event, after 1 minute, after successful deployment. I used the following ",(0,i.jsx)(t.a,{href:"https://docs.camunda.io/docs/reference/feel/what-is-feel",children:"feel expression"}),": ",(0,i.jsx)(t.code,{children:'=now()+ duration("PT1M")'}),". This is necessary, since only date and cycle are supported for ",(0,i.jsx)(t.a,{href:"https://docs.camunda.io/docs/reference/bpmn-workflows/timer-events/timer-events/#timer-start-events",children:"timer start events"}),"."]}),"\n",(0,i.jsx)(t.h4,{id:"continue-process-instance",children:"Continue process instance"}),"\n",(0,i.jsxs)(t.p,{children:["To continue and finish the process instance, we will activate the job with the ",(0,i.jsx)(t.code,{children:"chaos"})," job type and complete that job. If there is no job to activate/complete we will loop here until we reach the timeout. With this we can make sure that the timer was scheduled and the process instance was created even after restart. We are not using here an job worker, since the activate-complete commands make it currently easier to mark it as success or fail. With the job worker we would introduce another concurrency layer."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:'#!/bin/bash\nset -euox pipefail\n\nsource utils.sh\n\njobType=$1\nnamespace=$(getNamespace)\npod=$(getGateway)\n\nfunction completeJob() {\n  # we want to first activate the job with the given job type and then complete it with the given job key\n  # if we are not able to activate an job with the given type the function will return an error\n  # and retried from outside\n  jobs=$(kubectl exec -it "$pod" -n "$namespace" -- zbctl --insecure activate jobs "$jobType")\n  key=$(echo "$jobs" | jq -r \'.jobs[0].key\')\n  kubectl exec -it "$pod" -n "$namespace" -- zbctl --insecure complete job "$key"\n}\n\nretryUntilSuccess completeJob\n'})}),"\n",(0,i.jsx)(t.h3,{id:"outcome",children:"Outcome"}),"\n",(0,i.jsxs)(t.p,{children:["After running this experiment we get the following output, which shows us that the experiment ",(0,i.jsx)(t.strong,{children:"SUCCEEDED"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:"(chaostk) [zell helm/ cluster: zeebe-cluster ns:zell-chaos]$ chaos run process-continuation/experiment.json \n[2021-03-09 13:16:34 INFO] Validating the experiment's syntax\n[2021-03-09 13:16:34 INFO] Experiment looks valid\n[2021-03-09 13:16:34 INFO] Running experiment: Zeebe process instance continuation\n[2021-03-09 13:16:34 INFO] Steady-state strategy: default\n[2021-03-09 13:16:34 INFO] Rollbacks strategy: default\n[2021-03-09 13:16:34 INFO] Steady state hypothesis: Zeebe is alive\n[2021-03-09 13:16:34 INFO] Probe: All pods should be ready\n[2021-03-09 13:16:35 INFO] Steady state hypothesis is met!\n[2021-03-09 13:16:35 INFO] Playing your experiment's method now...\n[2021-03-09 13:16:35 INFO] Action: Deploy process model\n[2021-03-09 13:16:37 INFO] Action: Restart partition leader\n[2021-03-09 13:16:46 INFO] Probe: Complete process instance\n[2021-03-09 13:17:38 INFO] Steady state hypothesis: Zeebe is alive\n[2021-03-09 13:17:38 INFO] Probe: All pods should be ready\n[2021-03-09 13:17:38 INFO] Steady state hypothesis is met!\n[2021-03-09 13:17:38 INFO] Let's rollback...\n[2021-03-09 13:17:38 INFO] No declared rollbacks, let's move on.\n"})}),"\n",(0,i.jsx)(t.h4,{id:"testbench",children:"Testbench"}),"\n",(0,i.jsx)(t.p,{children:"Tbd."}),"\n",(0,i.jsxs)(t.p,{children:["We have currently some problems with running the chaos experiments against camunda cloud, like ",(0,i.jsx)(t.a,{href:"https://github.com/zeebe-io/zeebe-cluster-testbench/issues/247",children:"testbench#247"})," or ",(0,i.jsx)(t.a,{href:"https://github.com/zeebe-io/zeebe-cluster-testbench/issues/248",children:"testbench#248"}),". This is the reason why I postponed it."]}),"\n",(0,i.jsx)(t.h4,{id:"found-bugs",children:"Found Bugs"}),"\n",(0,i.jsx)(t.h5,{id:"chaos-experiments-not-working-correctly",children:"Chaos Experiments not working correctly"}),"\n",(0,i.jsxs)(t.p,{children:["I realized that most of the experiments are no longer run correctly, since they referring to ",(0,i.jsx)(t.code,{children:'"Leader"'})," as the raft role, where the raft role in the topology is ",(0,i.jsx)(t.code,{children:"LEADER"}),". This causes that on some experiments pods are not really restarted."]}),"\n",(0,i.jsx)(t.p,{children:"Almost everywhere we use constructs like:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:'\n        {\n            "type": "action",\n            "name": "Terminate leader of partition 3",\n            "provider": {\n                "type": "process",\n                "path": "shutdown-gracefully-partition.sh",\n                "arguments": [ "Leader", "3" ]\n            }\n        }\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In the utils script we use a ",(0,i.jsx)(t.code,{children:"jq"})," expression to get the node which is in a certain state for a certain partition."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"jq"})," expression looks like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:'  index=$(echo "$topology" | jq "[.brokers[]|select(.partitions[]| select(.partitionId == $partition) and .role == \\"$state\\")][0].nodeId")\n'})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"jq"})," is not able to find the raft ",(0,i.jsx)(t.code,{children:"state"})," which is returned by topology, if we use not capital letters."]}),"\n",(0,i.jsx)(t.p,{children:"When we run the chaos experiment we see warnings like:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:"(chaostk) [zell helm/ cluster: zeebe-cluster ns:zell-chaos]$ chaos run process-continuation/experiment.json \n[2021-03-09 13:27:01 INFO] Validating the experiment's syntax\n[2021-03-09 13:27:01 INFO] Experiment looks valid\n[2021-03-09 13:27:01 INFO] Running experiment: Zeebe process instance continuation\n[2021-03-09 13:27:01 INFO] Steady-state strategy: default\n[2021-03-09 13:27:01 INFO] Rollbacks strategy: default\n[2021-03-09 13:27:01 INFO] Steady state hypothesis: Zeebe is alive\n[2021-03-09 13:27:01 INFO] Probe: All pods should be ready\n[2021-03-09 13:27:02 INFO] Steady state hypothesis is met!\n[2021-03-09 13:27:02 INFO] Playing your experiment's method now...\n[2021-03-09 13:27:02 INFO] Action: Deploy process model\n[2021-03-09 13:27:03 INFO] Action: Restart partition leader\n[2021-03-09 13:27:05 WARNING] This process returned a non-zero exit code. This may indicate some error and not what you expected. Please have a look at the logs.\n\n"})}),"\n",(0,i.jsx)(t.p,{children:"The experiment still continues (in effect it does nothing, since it was not able to find the right pod to restart).\nConverting the state into capital letters fixes this issue easily."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:'function getIndexOfPodForPartitionInState()\n{\n  partition="$1"\n  # expect caps for raft roles\n  state=${2^^}\n'})}),"\n",(0,i.jsx)(t.h5,{id:"redeployment-causes-retrigger-timer",children:"Redeployment causes retrigger timer"}),"\n",(0,i.jsxs)(t.p,{children:["During running the chaos experiment and testing the scripts I realized that the timer start event is retriggered everytime I redeployed the exact deployment, which was kind of unexpected.\nI created a bug issue for that ",(0,i.jsx)(t.a,{href:"https://github.com/camunda-cloud/zeebe/issues/6515",children:"zeebe#6515"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},93218:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/chaosTimerStart-0c9330fda76374b0b56d57e595aea79d.png"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(96540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}},20349:e=>{e.exports=JSON.parse('{"permalink":"/zeebe-chaos/2021/03/09/cont-workflow-instance","editUrl":"https://github.com/zeebe-io/zeebe-chaos/blob/master/chaos-days/blog/2021-03-09-cont-workflow-instance/index.md","source":"@site/blog/2021-03-09-cont-workflow-instance/index.md","title":"Fault-tolerant processing of process instances","description":"Today I wanted to add another chaos experiment, to increase our automated chaos experiments collection. This time we will deploy a process model (with timer start event), restart a node and complete the process instance via zbctl.","date":"2021-03-09T00:00:00.000Z","tags":[{"inline":true,"label":"availability","permalink":"/zeebe-chaos/tags/availability"},{"inline":true,"label":"data","permalink":"/zeebe-chaos/tags/data"}],"readingTime":5.98,"hasTruncateMarker":true,"authors":[{"name":"Christopher Kujawa","title":"Chaos Engineer @ Zeebe","url":"https://github.com/zelldon","page":{"permalink":"/zeebe-chaos/authors/zell"},"imageURL":"https://github.com/zelldon.png","key":"zell"}],"frontMatter":{"layout":"posts","title":"Fault-tolerant processing of process instances","date":"2021-03-09T00:00:00.000Z","categories":["chaos_experiment","broker","processing"],"tags":["availability","data"],"authors":"zell"},"unlisted":false,"prevItem":{"title":"Camunda Cloud network partition","permalink":"/zeebe-chaos/2021/03/23/camunda-cloud-network-partition"},"nextItem":{"title":"Automating Deployment Distribution Chaos Experiment","permalink":"/zeebe-chaos/2021/02/23/automate-deployments-dist"}}')}}]);