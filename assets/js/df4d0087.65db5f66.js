"use strict";(globalThis.webpackChunkzell_chaos=globalThis.webpackChunkzell_chaos||[]).push([[7242],{13757:e=>{e.exports=JSON.parse('{"permalink":"/zeebe-chaos/2025/09/18/REST-API-From-ForkJoin-to-a-Dedicated-Thread-Pool","editUrl":"https://github.com/camunda/zeebe-chaos/blob/master/chaos-days/blog/2025-09-18-REST-API-From-ForkJoin-to-a-Dedicated-Thread-Pool/index.md","source":"@site/blog/2025-09-18-REST-API-From-ForkJoin-to-a-Dedicated-Thread-Pool/index.md","title":"REST API: From ForkJoin to a Dedicated Thread Pool","description":"During the latest REST API Performance load tests,","date":"2025-09-19T00:00:00.000Z","tags":[{"inline":true,"label":"availability","permalink":"/zeebe-chaos/tags/availability"}],"readingTime":6.405,"hasTruncateMarker":true,"authors":[{"name":"Berkay Can","title":"Software Engineer @ Zeebe","url":"https://github.com/berkaycanbc","imageURL":"https://github.com/berkaycanbc.png","key":"berkay","page":null}],"frontMatter":{"layout":"posts","title":"REST API: From ForkJoin to a Dedicated Thread Pool","date":"2025-09-19T00:00:00.000Z","categories":["chaos_experiment","bpmn"],"tags":["availability"],"authors":"berkay"},"unlisted":false,"prevItem":{"title":"Resilience of dynamic scaling","permalink":"/zeebe-chaos/2025/10/02/Dynamic-Scaling-Resilience"},"nextItem":{"title":"Resiliency against ELS unavailability","permalink":"/zeebe-chaos/2025/08/26/Resiliency-against-ELS-unavailability"}}')},28453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>s});var o=a(96540);const n={},i=o.createContext(n);function r(e){const t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),o.createElement(i.Provider,{value:t},e.children)}},29586:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var o=a(13757),n=a(74848),i=a(28453);const r={layout:"posts",title:"REST API: From ForkJoin to a Dedicated Thread Pool",date:new Date("2025-09-19T00:00:00.000Z"),categories:["chaos_experiment","bpmn"],tags:["availability"],authors:"berkay"},s="REST API: From ForkJoin to a Dedicated Thread Pool",l={authorsImageUrls:[void 0]},c=[];function d(e){const t={a:"a",p:"p",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["During the latest ",(0,n.jsx)(t.a,{href:"https://camunda.github.io/zeebe-chaos/2025/07/02/Follow-up-REST-API-performance",children:"REST API Performance load tests"}),",\nwe discovered that REST API requests suffered from significantly higher latency under CPU pressure, even when throughput numbers looked comparable.\nWhile adding more CPU cores alleviated the issue, this wasn\u2019t a sustainable solution \u2014 it hinted at an inefficiency in how REST handled broker responses.\nSee related ",(0,n.jsx)(t.a,{href:"https://camunda.github.io/zeebe-chaos/2025/07/02/Follow-up-REST-API-performance#request-handling-execution-logic",children:"section"})," from the previous blog post."]}),"\n",(0,n.jsxs)(t.p,{children:["This blog post is about how we diagnosed the issue, what we found, and the fix we introduced in ",(0,n.jsx)(t.a,{href:"https://github.com/camunda/camunda/pull/36517",children:"PR #36517"}),"\nto close the performance gap."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);