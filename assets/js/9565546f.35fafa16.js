"use strict";(globalThis.webpackChunkzell_chaos=globalThis.webpackChunkzell_chaos||[]).push([[7061],{12592(e){e.exports=JSON.parse('{"permalink":"/zeebe-chaos/2026/01/08/Experimenting-with-data-availability-metric","editUrl":"https://github.com/camunda/zeebe-chaos/blob/master/chaos-days/blog/2026-01-08-Experimenting-with-data-availability-metric/index.md","source":"@site/blog/2026-01-08-Experimenting-with-data-availability-metric/index.md","title":"Experimenting with data availability metric","description":"Happy new year everyone! Time for some chaos experiments again.","date":"2026-01-08T00:00:00.000Z","tags":[{"inline":true,"label":"availability","permalink":"/zeebe-chaos/tags/availability"}],"readingTime":8.36,"hasTruncateMarker":true,"authors":[{"name":"Christopher Kujawa","title":"Principal Software Engineer @ Camunda","url":"https://github.com/ChrisKujawa","page":{"permalink":"/zeebe-chaos/authors/zell"},"imageURL":"https://github.com/ChrisKujawa.png","key":"zell"}],"frontMatter":{"layout":"posts","title":"Experimenting with data availability metric","date":"2026-01-08T00:00:00.000Z","categories":["chaos_experiment","bpmn"],"tags":["availability"],"authors":["zell"]},"unlisted":false,"nextItem":{"title":"Building Confidence at Scale: How Camunda Ensures Platform Reliability Through Continuous Testing","permalink":"/zeebe-chaos/2025/12/11/Building-Confidence-at-Scale:-How-Camunda-Ensures-Platform-Reliability-Through-Continuous-Testing"}}')},28453(e,t,a){a.d(t,{R:()=>r,x:()=>o});var i=a(96540);const n={},s=i.createContext(n);function r(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(s.Provider,{value:t},e.children)}},48163(e,t,a){a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>h});var i=a(12592),n=a(74848),s=a(28453);const r={layout:"posts",title:"Experimenting with data availability metric",date:new Date("2026-01-08T00:00:00.000Z"),categories:["chaos_experiment","bpmn"],tags:["availability"],authors:["zell"]},o="Chaos Day Summary",l={authorsImageUrls:[void 0]},h=[];function c(e){const t={a:"a",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["Happy new year everyone ","\ud83c\udf89","! Time for some chaos experiments again ","\ud83d\ude03","."]}),"\n",(0,n.jsxs)(t.p,{children:["In today's chaos day, I was joined by ",(0,n.jsx)(t.a,{href:"https://github.com/pranjalg13",children:"Pranjal"})," our newest addition to the reliability testing team at Camunda (welcome ","\ud83c\udf89",")"]}),"\n",(0,n.jsxs)(t.p,{children:["We planned to experiment with the new data availability metric, which we have recently added to our load testing infrastructure, for more details see related ",(0,n.jsx)(t.a,{href:"https://github.com/camunda/camunda/pull/42553",children:"PR"}),". In short, we measure the time from creating a process instance until it is actually available to the user via the API. This allows us to reason how long it also takes for Operate to show new data."]}),"\n",(0,n.jsx)(t.p,{children:"The goal for today was to gain a better understanding of how the system behaves under higher loads and how this affects data availability. The focus was set here on the orchestration cluster, meaning data availability for Operate and Tasklist."}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"TL;DR;"})," We have observed that increasing the process instance creation rate leads to higher data availability times. While experimenting with different workloads we discovered that the ",(0,n.jsx)(t.a,{href:"https://github.com/camunda/camunda/issues/42244",children:"typical load test"})," is still not working well. During investigating the platform behaviors we discovered a recently introduced ",(0,n.jsx)(t.a,{href:"https://github.com/camunda/camunda/issues/43713",children:"regression"})," causing to limit our general max throughput, and identified ",(0,n.jsx)(t.a,{href:"https://github.com/camunda/camunda/issues/43715",children:"suboptimal error handling in the Gateway"})," causing request retries, which can exacerbate load issues."]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);