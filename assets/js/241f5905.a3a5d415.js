"use strict";(self.webpackChunkzell_chaos=self.webpackChunkzell_chaos||[]).push([[1563],{21727:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var n=s(74848),o=s(28453);const i={layout:"posts",title:"BPMN meets Chaos Engineering",date:new Date("2021-04-03T00:00:00.000Z"),categories:["chaos_experiment","bpmn"],tags:["tools"],authors:"zell"},a="BPMN meets Chaos Engineering",r={permalink:"/zeebe-chaos/2021/04/03/bpmn-meets-chaos-engineering",editUrl:"https://github.com/zeebe-io/zeebe-chaos/blob/master/chaos-days/blog/2021-04-03-bpmn-meets-chaos-engineering/index.md",source:"@site/blog/2021-04-03-bpmn-meets-chaos-engineering/index.md",title:"BPMN meets Chaos Engineering",description:"On the first of April (2021) we ran our Spring Hackday at Camunda. This is an event where the developers at camunda come together to work on projects they like or on new ideas/approaches they want to try out. This time we (Philipp and me) wanted to orchestrate our Chaos Experiments with BPMN. If you already know how we automated our chaos experiments before, you can skip the next section",date:"2021-04-03T00:00:00.000Z",tags:[{inline:!0,label:"tools",permalink:"/zeebe-chaos/tags/tools"}],readingTime:7.615,hasTruncateMarker:!0,authors:[{name:"Christopher Kujawa",title:"Chaos Engineer @ Zeebe",url:"https://github.com/zelldon",page:{permalink:"/zeebe-chaos/authors/zell"},imageURL:"https://github.com/zelldon.png",key:"zell"}],frontMatter:{layout:"posts",title:"BPMN meets Chaos Engineering",date:"2021-04-03T00:00:00.000Z",categories:["chaos_experiment","bpmn"],tags:["tools"],authors:"zell"},unlisted:!1,prevItem:{title:"Corrupted Snapshot Experiment Investigation",permalink:"/zeebe-chaos/2021/04/29/Corrupted-Snapshot"},nextItem:{title:"Set file immutable",permalink:"/zeebe-chaos/2021/03/30/set-file-immutable"}},h={authorsImageUrls:[void 0]},c=[{value:"Previous Chaos Automation",id:"previous-chaos-automation",level:2},{value:"List of Chaos Experiments",id:"list-of-chaos-experiments",level:3},{value:"Automated Chaos Experiments",id:"automated-chaos-experiments",level:3},{value:"Challenges",id:"challenges",level:3},{value:"Additional Dependency",id:"additional-dependency",level:4},{value:"Root Cause Analysis",id:"root-cause-analysis",level:4},{value:"Hackday Project",id:"hackday-project",level:2},{value:"Results",id:"results",level:3},{value:"Further Work",id:"further-work",level:3}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["On the first of April (2021) we ran our Spring Hackday at Camunda. This is an event where the developers at camunda come together to work on projects they like or on new ideas/approaches they want to try out. This time we (",(0,n.jsx)(t.a,{href:"https://github.com/saig0",children:"Philipp"})," and ",(0,n.jsx)(t.a,{href:"https://github.com/zelldon",children:"me"}),") wanted to orchestrate our Chaos Experiments with BPMN. If you already know how we automated our chaos experiments before, you can skip the next section\nand jump directly to the ",(0,n.jsx)(t.a,{href:"#hackday-project",children:"Hackday Project section"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"In order to understand this blogpost make sure that you have a little understanding of Zeebe, Camunda Cloud and Chaos Engineering. Read the following resources to get a better understanding."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://docs.camunda.io/docs/guides/",children:"Get Started with Camund cloud"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://docs.camunda.io/docs/product-manuals/clients/cli-client/get-started",children:"Quickstart Guide"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://camunda.com/de/products/cloud/",children:"Camunda Cloud"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://docs.camunda.io/docs/product-manuals/zeebe/zeebe-overview/",children:"Zeebe Process Engine"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://www.omg.org/spec/BPMN/2.0/About-BPMN/",children:"BPMN 2.0"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://principlesofchaos.org/",children:"Principles of Chaos"})}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"previous-chaos-automation",children:"Previous Chaos Automation"}),"\n",(0,n.jsxs)(t.p,{children:["In the previous Chaos Day summaries I described that we use ",(0,n.jsx)(t.a,{href:"https://chaostoolkit.org/",children:"ChaosToolkit"})," to run our chaos experiments. The chaos experiments have as prerequisite that an Zeebe cluster is already running, on which they should be executed. ChaosToolkit needs/uses a specific DSL to describe and execute Chaos Experiments. An example experiment looks like the following:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n    "version": "0.1.0",\n    "title": "Zeebe follower restart non-graceful experiment",\n    "description": "Zeebe should be fault-tolerant. Zeebe should be able to handle followers terminations.",\n    "contributions": {\n        "reliability": "high",\n        "availability": "high"\n    },\n    "steady-state-hypothesis": {\n        "title": "Zeebe is alive",\n        "probes": [\n            {\n                "name": "All pods should be ready",\n                "type": "probe",\n                "tolerance": 0,\n                "provider": {\n                    "type": "process",\n                    "path": "verify-readiness.sh",\n                    "timeout": 900\n                }\n            },\n            {\n                "name": "Should be able to create workflow instances on partition 1",\n                "type": "probe",\n                "tolerance": 0,\n                "provider": {\n                    "type": "process",\n                    "path": "verify-steady-state.sh",\n                    "arguments": "1",\n                    "timeout": 900\n                }\n            }\n        ]\n    },\n    "method": [\n        {\n            "type": "action",\n            "name": "Terminate follower of partition 1",\n            "provider": {\n                "type": "process",\n                "path": "terminate-partition.sh",\n                "arguments": [ "Follower", "1"]\n            }\n        }\n    ],\n    "rollbacks": []\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"This JSON describes a chaos experiment where a follower of partition one is terminated, and where we expect that we can create a new process instance before and after this termination. The follower termination should not affect our steady state."}),"\n",(0,n.jsxs)(t.p,{children:["In the JSON structure we can see the defined steady state of the Zeebe Cluster and the method/action which should be executed (the chaos which should be injected). The defined steady state is verified at the beginning of the experiment and at the end, after the methods are executed. The execution logic is quite simple. You can also define rollback actions, which should be executed if the experiment fails. Timeouts can be defined for each action and probe. Since the ",(0,n.jsx)(t.code,{children:"chaosToolkit"})," is written in Python you can reference python modules/functions, which should be called during execution. Additionally, it supports bash scripts, which we normally use. Unfortunately bash scripts are sometimes not easy to understand and to maintain. This is one of the reason why we already thought more than once to replace the ",(0,n.jsx)(t.code,{children:"chaosToolkit"})," with something different."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"chaosToolkit"})," has more features and extensions, but these are not used by us."]}),"\n",(0,n.jsx)(t.h3,{id:"list-of-chaos-experiments",children:"List of Chaos Experiments"}),"\n",(0,n.jsxs)(t.p,{children:["The experiment above is just one experiment of our continuous growing collection of chaos experiments, which we have already defined. There exist chaos experiments for the helm charts, but also for camunda cloud, for each cluster plan separately. You can find them ",(0,n.jsx)(t.a,{href:"https://github.com/zeebe-io/zeebe-chaos/tree/master/chaos-experiments",children:"here"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"automated-chaos-experiments",children:"Automated Chaos Experiments"}),"\n",(0,n.jsxs)(t.p,{children:["Chaos experiments need to be executed continously, not only once. For that we have build an automated pipeline, which runs the chaos experiments every night or if requested. We did that with help of the ",(0,n.jsx)(t.a,{href:"https://github.com/zeebe-io/zeebe-cluster-testbench",children:"Zeebe Cluster Testbench"}),", we call it just ",(0,n.jsx)(t.code,{children:"testbench"}),". The ",(0,n.jsx)(t.code,{children:"testbench"})," creates for each cluster plan, in camunda cloud, a Zeebe cluster and runs the corresponding experiments against these clusters. The process model looks quite simple."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"chaos-test",src:s(61516).A+"",width:"783",height:"276"})}),"\n",(0,n.jsxs)(t.p,{children:["It is executed via a ",(0,n.jsx)(t.a,{href:"https://github.com/zeebe-io/zeebe-cluster-testbench/tree/develop/core/chaos-workers",children:"zbctl chaos worker"}),", which is part of the ",(0,n.jsx)(t.code,{children:"testbench"}),". The ",(0,n.jsx)(t.code,{children:"chaos worker"})," polls for new jobs at the ",(0,n.jsx)(t.code,{children:"testbench"}),". On new jobs it executes, based on the cluster plan, against the given/created Zeebe cluster the chaos experiments, via the ",(0,n.jsx)(t.code,{children:"chaostoolkit"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["In general this was a good first solution, which is quite extensible since we just needed to add new experiments in the ",(0,n.jsx)(t.a,{href:"https://github.com/zeebe-io/zeebe-chaos",children:"zeebe-chaos"})," repository and on the next run the experiments are executed, without any further adjustments."]}),"\n",(0,n.jsx)(t.h3,{id:"challenges",children:"Challenges"}),"\n",(0,n.jsx)(t.p,{children:"Still, we had some challenges with this approach."}),"\n",(0,n.jsx)(t.h4,{id:"additional-dependency",children:"Additional Dependency"}),"\n",(0,n.jsxs)(t.p,{children:["With the ",(0,n.jsx)(t.code,{children:"chaosToolkit"})," we had an additional dependency. If you want to implement/write new chaos experiments you need to set up the ",(0,n.jsx)(t.code,{children:"chaosToolkit"})," on your machine, with the correct Python etc. In general the setup guide was straight forward, but still it was something you need to have. It made the adoption harder."]}),"\n",(0,n.jsx)(t.h4,{id:"root-cause-analysis",children:"Root Cause Analysis"}),"\n",(0,n.jsx)(t.p,{children:"Due to our setup it was a bit more challenging todo the root cause analysis."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ChaosOutput",src:s(95850).A+"",width:"692",height:"597"})}),"\n",(0,n.jsxs)(t.p,{children:["We run a ",(0,n.jsx)(t.code,{children:"zbctl"})," worker in a docker image, which picks up the ",(0,n.jsx)(t.code,{children:"chaos"})," typed jobs. An ",(0,n.jsx)(t.code,{children:"zbctl"})," worker will complete jobs with the output of the called handler script. This means that everything, which you want to log, needs to be logged in a separate file. The ",(0,n.jsx)(t.code,{children:"chaosToolkit"})," will print its output into an own log file. The output of the bash scripts, which are executed by the ",(0,n.jsx)(t.code,{children:"chaosToolkit"}),", will also end in that ",(0,n.jsx)(t.code,{children:"chaosToolkit.log"})," file. I tried to visualize this a bit with the image above."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"chaos-test",src:s(68264).A+"",width:"1897",height:"921"})}),"\n",(0,n.jsxs)(t.p,{children:["If the chaos worker completes a job, the process instance in ",(0,n.jsx)(t.code,{children:"testbench"})," is continued. If a chaos experiment fails, then the job is still completed normally, but with an error result. In the process instance execution this means that a different path is taken. The ",(0,n.jsx)(t.code,{children:"testbench"})," will write a slack notification to a specific channel, such that the current Zeebe medic can look at it."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"run-test",src:s(65011).A+"",width:"3504",height:"816"})}),"\n",(0,n.jsxs)(t.p,{children:["After the notification the medic needs to find out which experiment has failed, this is part of the payload of the completed job at least, but he also needs to find out why the experiment failed. For this root cause analysis he has to check the log of the ",(0,n.jsx)(t.code,{children:"chaostoolkit"}),", which is stored somewhere in the chaos worker pod (",(0,n.jsx)(t.code,{children:"data/chaostoolkit.log"})," it is an ever growing log)."]}),"\n",(0,n.jsx)(t.h2,{id:"hackday-project",children:"Hackday Project"}),"\n",(0,n.jsx)(t.p,{children:"With our Hackday Project we had two goals:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"lower the bar for team adoption"}),"\n",(0,n.jsx)(t.li,{children:"make root cause analysis easier"}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["For that we wanted to replace ",(0,n.jsx)(t.code,{children:"chaosToolkit"})," with a BPMN Process, which should be executed by Zeebe. We wanted to stick with the experiment description (the ",(0,n.jsx)(t.code,{children:"chaosToolkit"}),"/openchaos DSL) for our chaos experiments."]}),"\n",(0,n.jsxs)(t.p,{children:["We modeled two processes. One root process, which reads for a given cluster plan all experiments and runs then each experiment. This is done via a ",(0,n.jsx)(t.a,{href:"https://docs.camunda.io/docs/0.25/product-manuals/zeebe/bpmn-workflows/multi-instance/multi-instance/",children:"multi instance"})," ",(0,n.jsx)(t.a,{href:"https://docs.camunda.io/docs/reference/bpmn-workflows/call-activities/call-activities/",children:"call activity"}),"."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ChaosOutput",src:s(57819).A+"",width:"1449",height:"312"})}),"\n",(0,n.jsxs)(t.p,{children:["The other process model is used for the real chaos experiment execution. As the ",(0,n.jsx)(t.code,{children:"chaosToolkit"})," execution itself was quite simple, the resulting BPMN model is as well. All activities are\nsequential multi instances, since we can have multiple probes/actions for the steady state, but also for the injection of chaos. On the root level of the process we have an interrupting ",(0,n.jsx)(t.a,{href:"https://docs.camunda.io/docs/reference/bpmn-workflows/event-subprocesses/event-subprocesses/",children:"event sub process"})," to timeout the chaos experiment if the experiment takes to long."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ChaosExperiment",src:s(97644).A+"",width:"1923",height:"1215"})}),"\n",(0,n.jsx)(t.p,{children:"As payload of the process instances we have the defined chaos experiment in JSON, which we have seen earlier. In this JSON we have all information we need to orchestrate this experiment."}),"\n",(0,n.jsxs)(t.p,{children:["We have implemented two Kotlin workers, one to read all experiment JSON files and one to execute the bash scripts, which are referenced in the chaos experiment descriptions. You can find the code ",(0,n.jsx)(t.a,{href:"https://github.com/zeebe-io/zeebe-chaos/tree/master/chaos-model/chaos-worker",children:"here"}),", it is just 100 lines long."]}),"\n",(0,n.jsx)(t.h3,{id:"results",children:"Results"}),"\n",(0,n.jsx)(t.p,{children:"We orchestrated the follower/leader termination and graceful shutdown experiments via Camunda Cloud and the created process models. The experiments have been executed against another Zeebe cluster successfully."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"success",src:s(23436).A+"",width:"1911",height:"817"})}),"\n",(0,n.jsx)(t.p,{children:"To see how we improved the observability, we provoked an experiment to fail. Operate shows use via an incident that an experiment failed, and exactly at which step."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"failure",src:s(33141).A+"",width:"1906",height:"838"})}),"\n",(0,n.jsx)(t.p,{children:"We can even see the standard output and error output of the executed script in operate, without searching different log files."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"failuremsg",src:s(8831).A+"",width:"1909",height:"832"})}),"\n",(0,n.jsx)(t.p,{children:"An timeout of an experiment will look like this:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"timeout",src:s(44236).A+"",width:"1907",height:"822"})}),"\n",(0,n.jsx)(t.p,{children:"As we can see the observability improved here a lot. We are able to understand why it failed based on the error message, since the complete error output is printed, and we can see the progress of the process instance on running the chaos experiment."}),"\n",(0,n.jsxs)(t.p,{children:["With these models we were able to completely replace the ",(0,n.jsx)(t.code,{children:"chaosToolkit"})," usage, so in the end we can remove an additional dependency."]}),"\n",(0,n.jsx)(t.h3,{id:"further-work",children:"Further Work"}),"\n",(0,n.jsxs)(t.p,{children:["Next step would be to integrate this in ",(0,n.jsx)(t.code,{children:"testbench"}),", such that we can replace the old ",(0,n.jsx)(t.code,{children:"chaos worker"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Furthermore, we plan to replace step by step the new worker, which calls the scripts, by workers which have the script logic inside. For example with workers written in go or kotlin. This should improve the adoption and maintainability further."}),"\n",(0,n.jsx)(t.p,{children:"For simplicity and to make progress we modeled quite generic process models, which are feed with the chaos experiment DSL. In the future we can also think of modeling the chaos experiments directly as BPMN model."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsxs)(t.strong,{children:["Thanks to ",(0,n.jsx)(t.a,{href:"https://github.com/pihme",children:"Peter"})," for giving the impulse and his awesome work on ",(0,n.jsx)(t.code,{children:"testbench"})," and ",(0,n.jsx)(t.a,{href:"https://github.com/saig0",children:"Philipp"})," which worked with me on this Hackday project."]})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},95850:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/ChaosOutput-d308a3d2d0bcccb37e4f284e6f0644ad.png"},61516:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/chaos-test-8f97386338e64270714be0f3a7adc291.png"},97644:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/chaosExperiment-a625cf5634ccf0629a70f3717115be82.png"},57819:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/chaosToolkit-b205b8a3611844c5a45a1f0a6f0723bd.png"},8831:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/fail-run-output-06271ff74f1049c9036ce88895dfb39e.png"},33141:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/fail-run-4f1f6cbbb18170bd0947abf0a9d471f8.png"},68264:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/failed-chaos-experiment-testbench-31d2cac3b2dd367edfa979255a11ba49.png"},65011:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/run-test-in-camunda-cloud-61406278623b76fb1720819df03769a1.png"},23436:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/success-run-d7e1671a0d070ea7290ae2565902b4a8.png"},44236:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/timeout-run-67874e1d4b6c866fc3c04dfdf16148dd.png"},28453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>r});var n=s(96540);const o={},i=n.createContext(o);function a(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);